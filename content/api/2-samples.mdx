---
title: "Sample Workflow"
metaTitle: "Sample Workflow"
metaDescription: "Spectro Cloud API Sample Workflow"
icon: ""
hideToC: true
fullWidth: false
hiddenFromNav: false
hideToCSidebar: true
---
import {Intro, IntroButtons} from "shared/components"
import InfoBox from "shared/components/InfoBox"
import Tabs from 'shared/components/ui/Tabs';
import WarningBox from 'shared/components/WarningBox';


# Overview

This workflow demonstrates how to use Spectro Cloud API. You can use the API to automate the provisioning of Kubernetes clusters and applications on Spectro Cloud. 

The API is a RESTful API that uses JSON for serialization and supports HTTP Basic Authentication and token authentication. The API is available at `https://api.spectrocloud.com`.

Use the following examples to familiarize yourself with the API. 

<br />

<WarningBox>

The following samples are for demonstration purposes only and may lack all the required payload values. They are not intended for production use.
We recommend exploring the API using a tool such as [Postman](https://www.postman.com/) and our available Postman collection.
Check out the [Postman collection](api/v1/overview#postman-collection) resource to learn more about the Palette API Postman collection.

</WarningBox>

<br />

## Prerequisites

* You must have a Spectro Cloud account. If you do not have an account, you can create one at [https://console.spectrocloud.com](https://console.spectrocloud.com).


* An Authentication header with a token value or an API Key with an ApiKey value. 
Learn more about authentication credentials by reviewing the [authentication methods](https://docs.spectrocloud.com/user-management/user-authentication) resource.


* You must have a Spectro Cloud cluster. You can create a cluster from the Spectro Cloud console.


* The respective language runtime and package manager installed on your machine. 



* [jq](https://stedolan.github.io/jq/download/) - A command-line JSON processor.

## Configure Scope and Authentication

In the following examples, the following variables are used to interact with the Palette API. The values for these variables are specific to your environment.
The project ID is the UID of the project in which you want to create the cluster. You can find the project ID in the Palette dashboard, top right-hand corner.

<br />

```shell
export API_KEY="Your API Key"
```
<br />

```shell
export PROJECT_ID="Your Project UID"
```

Some of the endpoints require a cluster ID.




<InfoBox>

If you do not provide the ProjectUid header, then the assumed scope is of the tenant.

</InfoBox>


# Deploy a Cluster

You can use the following endpoint to deploy a cluster. The provider value represents the cloud provider on which you want to deploy the cluster, such as public cloud or on-prem.

**Endpoint**: `https://api.spectrocloud.com/v1/spectroclusters/{provider}`

Set the provider as an environment variable. 

```shell
export PROVIDER="Your Provider"
```

The payload for creating a host cluster can be lengthy due to the various configurations available for a host cluster. To improve readbility, the payload is condensed in the following examples and lack required values. 
Check out the [Clusters](/api/v1/clusters) API resource to learn more about the available parameters.

<br />

```shell 
export PAYLOAD='{
	"metadata": {
		"annotations": {},
		"name": "my-cluster",
		"labels": {}
	},
	"spec": {....}
}'
```


<Tabs>

<Tabs.TabPane tab="curl" key="cluster-create-curl">

```shell
curl --location 'https://api.spectrocloud.com/v1/spectroclusters/$PROVIDER?ProjectUid=$PROJECT_ID"' \
 --header 'Content-Type: application/json' \
 --header 'Accept: application/json' \
 --header "ApiKey: $API_KEY"
 --data  "$PAYLOAD"
```

</Tabs.TabPane> 

<Tabs.TabPane tab="JavaScript" key="cluster-create-js">

```js
const apiKey = process.env.API_KEY;
const projectID = process.env.PROJECT_ID;
const provider = process.env.PROVIDER; // Or specify the provider directly such as "aws", "aks", "openstack"

// Build the request URL
const url = `https://api.spectrocloud.com/v1/spectroclusters/${provider}?ProjectUid=${projectID}`;

// Define data payload for the request
const data = {
  metadata: {
    annotations: {},
    name: "my-cluster",
    labels: {}
  },
  spec: {
    // ...
  }
};

// Define headers for the request
const headers = new Headers({
  "Content-Type": "application/json",
  "Accept": "application/json",
  "ApiKey": apiKey
});

// Define async function to send POST request
async function sendRequest() {
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: headers,
      body: JSON.stringify(data)
    });
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }
    const responseData = await response.json();
    console.log(responseData);
  } catch (error) {
    console.error(error);
  }
}
sendRequest();
```
</Tabs.TabPane> 

<Tabs.TabPane tab="Go" key="cluster-create-go">

```go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
)

func main() {
	apiKey := os.Getenv("API_KEY")
	projectID := os.Getenv("PROJECT_ID")
	provider := os.Getenv("PROVIDER")

	url := fmt.Sprintf("https://api.spectrocloud.com/v1/spectroclusters/%s?ProjectUid=%s", provider, projectID)


	data := map[string]interface{}{
		"metadata": map[string]interface{}{
			"annotations": map[string]interface{}{},
			"name":        "my-cluster",
			"labels":      map[string]interface{}{},
		},
		"spec": map[string]interface{}{
			// ...
		},
	}

	// Convert data payload to JSON
	jsonData, err := json.Marshal(data)
	if err != nil {
		panic(err)
	}

	// Define headers for the request
	headers := http.Header{}
	headers.Set("Content-Type", "application/json")
	headers.Set("Accept", "application/json")
	headers.Set("ApiKey", apiKey)

	// Send POST request with data payload
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	// Parse response data as JSON
	var responseData map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&responseData)
	if err != nil {
		panic(err)
	}

	fmt.Println(responseData)
}
```
</Tabs.TabPane> 

<Tabs.TabPane tab="Rust" key="cluster-create-rust">

```rust
use std::collections::HashMap;
use std::env;
use std::io::Read;

use reqwest::header::{HeaderMap, HeaderValue, CONTENT_TYPE};
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Serialize, Deserialize, Debug)]
struct ClusterData {
    metadata: Metadata,
    spec: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Metadata {
    annotations: HashMap<String, String>,
    name: String,
    labels: HashMap<String, String>,
}

async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let api_key = env::var("API_KEY")?;
    let project_id = env::var("PROJECT_ID")?;
    let provider = env::var("PROVIDER")?;

    let url = format!(
        "https://api.spectrocloud.com/v1/spectroclusters/{}?ProjectUid={}",
        provider, project_id
    );

    let data = ClusterData {
        metadata: Metadata {
            annotations: HashMap::new(),
            name: "my-cluster".to_string(),
            labels: HashMap::new(),
        },
        spec: HashMap::new(),
    };

    let client = reqwest::Client::new();
    let mut headers = HeaderMap::new();
    headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
    headers.insert("Accept", HeaderValue::from_static("application/json"));
    headers.insert("ApiKey", HeaderValue::from_str(&api_key)?);

    let resp = client.post(&url).headers(headers).json(&data).send().await?;
    let mut resp_body = String::new();
    resp.text().await?.read_to_string(&mut resp_body)?;

    let response_data: HashMap<String, serde_json::Value> = serde_json::from_str(&resp_body)?;
    println!("{:?}", response_data);

    Ok(())
}
```
</Tabs.TabPane> 

</Tabs>




# Cluster Nodes and Node Status

You can use the following endpoint to retrieve the list of nodes in a cluster and their status.

**Endpoint**: `https://api.spectrocloud.com/v1/spectroclusters/{uid}`

Ensure you specify the cluster ID. You can set the cluster ID as an environment variable. 

```shell
export CLUSTER_ID="Your Cluster ID"
```

## All Cluster Node Data

<br />

<Tabs>

<Tabs.TabPane tab="curl" key="node-status-curl">

```shell
curl --location "https://api.spectrocloud.com/v1/spectroclusters/$CLUSTER_ID?ProjectUid=$PROJECT_ID" \
 --header 'Accept: application/json' \
 --header "ApiKey: $API_KEY"
```

</Tabs.TabPane>

<Tabs.TabPane tab="JavaScript" key="node-status-js">


```js
// Get API key, project ID, and cluster ID from environment variables
const apiKey = process.env.API_KEY;
const projectID = process.env.PROJECT_ID;
const clusterID = process.env.CLUSTER_ID;

// Build the request URL
const url = `https://api.spectrocloud.com/v1/spectroclusters/${clusterID}?ProjectUid=${projectID}`;

// Define headers for the request
const headers = new Headers({
  "Accept": "application/json",
  "ApiKey": apiKey
});

// Define an async function to send the HTTP request
async function fetchData() {
  try {
    // Send the HTTP request using the fetch() method
    const response = await fetch(url, {
      method: "GET",
      headers: headers
    });
    const data = await response.json();
    console.log("Response data:", data);
  } catch (error) {
    console.error(error);
  }
}

// Call the async function to send the HTTP request
fetchData();
```

</Tabs.TabPane>

<Tabs.TabPane tab="Go" key="node-status-go">

```go
package main

import (
	"fmt"
	"net/http"
	"io/ioutil"
	"os"
)

func main() {
	// Get API key, project ID and cluster ID from environment variables
	apiKey := os.Getenv("API_KEY")
	projectID := os.Getenv("PROJECT_ID")
	clusterID := os.Getenv("CLUSTER_ID")

	// Create a new HTTP request
	req, err := http.NewRequest("GET", fmt.Sprintf("https://api.spectrocloud.com/v1/spectroclusters/%s?ProjectUid=%s", clusterID, projectID), nil)
	if err != nil {
		fmt.Println("Error creating HTTP request:", err)
		return
	}

	// Add headers to the request
	req.Header.Add("Accept", "application/json")
	req.Header.Add("ApiKey", apiKey)

	// Send the HTTP request
	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending HTTP request:", err)
		return
	}
	defer resp.Body.Close()

	// Read the response body
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Error reading HTTP response:", err)
		return
	}

	// Print the response body
	fmt.Println(string(body))
}

```

</Tabs.TabPane>

<Tabs.TabPane tab="Python" key="node-status-python">

```python
import os
import requests

# Get API key, project ID, and cluster ID from environment variables
api_key = os.environ.get("API_KEY")
project_id = os.environ.get("PROJECT_ID")
cluster_id = os.environ.get("CLUSTER_ID")

# Build the request URL
url = f"https://api.spectrocloud.com/v1/spectroclusters/{cluster_id}?ProjectUid={project_id}"

# Define headers for the request
headers = {
  "Accept": "application/json",
  "ApiKey": api_key
}

# Send the HTTP request using the requests library
response = requests.get(url, headers=headers)

# Check the response status code
if response.status_code == 200:
  # Print the response data (JSON format)
  print("Response data:", response.json())
else:
  # Print the error message if the request failed
  print("Request failed with status code:", response.status_code)
```

</Tabs.TabPane>

<Tabs.TabPane tab="Rust" key="node-status-rust">

```
use std::env;
use reqwest::header::{HeaderMap, HeaderValue, ACCEPT, APIKEY};

#[tokio::main]
async fn main() -> Result<(), reqwest::Error> {
    // Set API key, project ID, and cluster ID as environment variables
    let api_key = env::var("API_KEY").unwrap();
    let project_id = env::var("PROJECT_ID").unwrap();
    let cluster_id = env::var("CLUSTER_ID").unwrap();

    // Build the request URL
    let url = format!("https://api.spectrocloud.com/v1/spectroclusters/{}?ProjectUid={}", cluster_id, project_id);

    // Define headers for the request
    let mut headers = HeaderMap::new();
    headers.insert(ACCEPT, HeaderValue::from_static("application/json"));
    headers.insert(APIKEY, HeaderValue::from_str(&api_key).unwrap());

    // Send the HTTP request using the reqwest crate
    let response = reqwest::Client::new()
        .get(&url)
        .headers(headers)
        .send()
        .await?;

    // Check the response status code
    if response.status().is_success() {
        // Print the response data (JSON format)
        let body = response.text().await?;
        println!("Response data: {}", body);
    } else {
        // Print the error message if the request failed
        println!("Request failed with status code: {}", response.status());
    }

    Ok(())
}
```

</Tabs.TabPane>


</Tabs>

##  Retrieve the Cluster Cloud Config Identifier

The cloud config identifier is a unique identifier for the cloud config that is used to provision the cluster. 
The values are found in the `spec.cloudConfigRef` field of the cluster object. You can use the following code snippet to retrieve the cluster cloud config identifier `uid` and `kind`. 

<br />

<Tabs>

<Tabs.TabPane tab="curl" key="config-identifier-curl">

```shell
curl -s --location "https://api.spectrocloud.com/v1/spectroclusters/$CLUSTER_ID?ProjectUid=$PROJECT_ID" \
 --header 'Accept: application/json' \
 --header "ApiKey: $API_KEY" \
 | jq -r '.spec.cloudConfigRef | "\(.kind) \(.uid)"'
```

</Tabs.TabPane>

<Tabs.TabPane tab="JavaScript" key="config-identifier-js">

```js
// Get API key, project ID, and cluster ID from environment variables
const apiKey = process.env.API_KEY;
const projectID = process.env.PROJECT_ID;
const clusterID = process.env.CLUSTER_ID;

// Build the request URL
const url = `https://api.spectrocloud.com/v1/spectroclusters/${clusterID}?ProjectUid=${projectID}`;

// Define headers for the request
const headers = new Headers({
  "Accept": "application/json",
  "ApiKey": apiKey
});

// Define an async function to send the HTTP request
async function fetchData() {
  try {
    // Send the HTTP request using the fetch() method
    const response = await fetch(url, {
      method: "GET",
      headers: headers
    });

    // Parse the response as JSON
    const data = await response.json();

    // Extract the required values from the response
    const cloudConfigRef = data.spec.cloudConfigRef;
    const kind = cloudConfigRef.kind;
    const uid = cloudConfigRef.uid;

    // Print the values
    console.log(`kind: ${kind}`);
    console.log(`uid: ${uid}`);
  } catch (error) {
    console.error(error);
  }
}

// Call the async function to send the HTTP request
fetchData();
```
</Tabs.TabPane>


<Tabs.TabPane tab="Go" key="config-identifier-go">

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

type Response struct {
	Spec struct {
		CloudConfigRef struct {
			Kind string `json:"kind"`
			Uid  string `json:"uid"`
		} `json:"cloudConfigRef"`
	} `json:"spec"`
}

func main() {
	// Get API key, project ID and cluster ID from environment variables
	apiKey := os.Getenv("API_KEY")
	projectID := os.Getenv("PROJECT_ID")
	clusterID := os.Getenv("CLUSTER_ID")

	// Create a new HTTP request
	req, err := http.NewRequest("GET", fmt.Sprintf("https://api.spectrocloud.com/v1/spectroclusters/%s?ProjectUid=%s", clusterID, projectID), nil)
	if err != nil {
		fmt.Println("Error creating HTTP request:", err)
		return
	}

	// Add headers to the request
	req.Header.Add("Accept", "application/json")
	req.Header.Add("ApiKey", apiKey)

	// Send the HTTP request
	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending HTTP request:", err)
		return
	}
	defer resp.Body.Close()

	// Read the response body
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Error reading HTTP response:", err)
		return
	}

	// Unmarshal the JSON response into a Response struct
	var response Response
	err = json.Unmarshal(body, &response)
	if err != nil {
		fmt.Println("Error unmarshaling JSON response:", err)
		return
	}

	// Print the cloudConfigRef kind and uid
	fmt.Printf("Kind: %s\nUid: %s\n", response.Spec.CloudConfigRef.Kind, response.Spec.CloudConfigRef.Uid)
}
```

</Tabs.TabPane>

<Tabs.TabPane tab="Python" key="config-identifier-python">

```python
import os
import requests

# Get API key, project ID, and cluster ID from environment variables
api_key = os.environ.get("API_KEY")
project_id = os.environ.get("PROJECT_ID")
cluster_id = os.environ.get("CLUSTER_ID")

# Build the request URL
url = f"https://api.spectrocloud.com/v1/spectroclusters/{cluster_id}?ProjectUid={project_id}"

# Define headers for the request
headers = {
  "Accept": "application/json",
  "ApiKey": api_key
}

# Send the HTTP request using the requests library
response = requests.get(url, headers=headers)

# Check the response status code
if response.status_code == 200:
  # Parse the response JSON and extract the values
  response_json = response.json()
  kind = response_json['spec']['cloudConfigRef']['kind']
  uid = response_json['spec']['cloudConfigRef']['uid']

  # Print the extracted values
  print(f"Kind: {kind}")
  print(f"UID: {uid}")
else:
  # Print the error message if the request failed
  print("Request failed with status code:", response.status_code)
```
</Tabs.TabPane>

<Tabs.TabPane tab="Rust" key="config-identifier-rust">

```
use std::env;
use reqwest::header::{HeaderMap, HeaderValue, ACCEPT, APIKEY};
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Deserialize, Serialize)]
struct SpectroCluster {
    metadata: Value,
    spec: SpectroClusterSpec,
}

#[derive(Debug, Deserialize, Serialize)]
struct SpectroClusterSpec {
    cloud_config_ref: CloudConfigRef,
}

#[derive(Debug, Deserialize, Serialize)]
struct CloudConfigRef {
    kind: String,
    uid: String,
}

#[tokio::main]
async fn main() -> Result<(), reqwest::Error> {
    // Set API key, project ID, and cluster ID as environment variables
    let api_key = env::var("API_KEY").unwrap();
    let project_id = env::var("PROJECT_ID").unwrap();
    let cluster_id = env::var("CLUSTER_ID").unwrap();

    // Build the request URL
    let url = format!("https://api.spectrocloud.com/v1/spectroclusters/{}?ProjectUid={}", cluster_id, project_id);

    // Define headers for the request
    let mut headers = HeaderMap::new();
    headers.insert(ACCEPT, HeaderValue::from_static("application/json"));
    headers.insert(APIKEY, HeaderValue::from_str(&api_key).unwrap());

    // Send the HTTP request using the reqwest crate
    let response = reqwest::Client::new()
        .get(&url)
        .headers(headers)
        .send()
        .await?;

    // Check the response status code
    if response.status().is_success() {
        // Deserialize the response data to a SpectroCluster struct
        let cluster: SpectroCluster = response.json().await?;

        // Extract spec.cloudConfigRef.kind and spec.cloudConfigRef.uid
        let kind = cluster.spec.cloud_config_ref.kind;
        let uid = cluster.spec.cloud_config_ref.uid;
        println!("kind: {}", kind);
        println!("uid: {}", uid);
    } else {
        // Print the error message if the request failed
        println!("Request failed with status code: {}", response.status());
    }

    Ok(())
}
```

</Tabs.TabPane>


</Tabs>




